************** interview problem (the Android phone system)

You should *** define the API *** for an alarm application, similar to the Android/iPhone phone (do NOT implement it).

- When adding/editing an alarm, you can set/change: 
  - Time-of-day (when alarm is to be triggered)
  - Alarm name
  - Snooze period (any of : 5, 10, 15, 20, 25, 30 minutes)
  - Ringtone
  - Repeat, which can be any of: 
    - Only-for-today: alarm will sound today; whe user stops the alarm, it turns itself off.
    - Days-of-week: you specify which days of the week the alarm is to sound on. When user stops the alarm, the alarm marks itself as "turned off for today", but remains turned  on, and it will sound again on the next day of the week it's set to. If you set an alarm for Mon + Wed: when you stop it on Monday, it will sound on Wednesday. When you stop it on Wednesday, it will sound again next Monday, and so on.
- User can manually turn an alarm on or off.


When the alarm sounds:
- it shows the alarm name if set, or shows "Alarm"
- it plays the ringtone, and 
- the user can either stop it or snooze it (by default -- by the snooze period set by the alarm. But, the user can override that period)
- snoozing will postpone sounding the alarm for today, while NOT altering the alarm itself.
- the user can snooze an alarm indefinitely.


For each turned on alarm, starting 30 minutes before alarm is about to sound, the application shows a notification:
- the user can turn off the alarm before it even starts
- depending on the alarm type, the notification will show "Turn off" (for Only-for-today alarms) or "Turn off for today" (for Days-of-week alarms)
- clicking on the notification will Turn off the alarm ahead of time. 
  - For Only-for-today alarms, the alarm is turned off.
  - For Days-of-week alarms, the alarm is turned off. However, the alarm automatically turns itself on once the time the alarm should sound on passes.




Define just the business logic interfaces, and comment out what each function should do. You should define it in such a way, that if someone else later implemnents the User Interface, he would not need to alter the business logic at all.

In case you need to use any enumerations (such as: day of the week), define them.

So, in C#, you can start with something like:

    public interface IAlarm
    {
        // this gets/sets the alarm name, default: Empty
        string AlarmName { get; set; }
        ...
    }

    public interface IAlarmCollection
    {
        // returns all the existing alarms
        IReadOnlyList<IAlarm> Alarms { get; }
        ...
    }

and in C++ , you can start with something like:

    class IAlarm {
    public:
        // this gets/sets the alarm name, default: Empty
        void AlamName(const std::string& name) ;
        const std::string& AlamName() const ;
        ...
    };

    class IAlarmCollection {
    public:
        // returns all the existing alarms
        std::vector<IAlarm> SomeFunction() ;
        ...
    };

Assume there's a function that returns the time, and there's a function that returns the current day-of-the-week.